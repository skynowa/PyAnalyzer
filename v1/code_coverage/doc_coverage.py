#!/usr/bin/env python

"""Generate code coverage report for documentation generated by doxygen.

Form html page to display if the code is covered with comments well. 
Requires doxygen documentation to be generated previously.
Also the source code assumed to be accessible.
"""

import re
import subprocess
from os import system, listdir
from os.path import isfile, join, dirname, realpath
from datetime import date
from typing import List, Dict


def get_subprojects_list(base_source_path : str) -> List:
    """
    Gets the subprojects list (subfolders in a root folder of the project).
    
    :param      base_source_path:  Path to root folder of the project

    :returns:   The subprojects list.
    """

    subprojects = [f for f in listdir(base_source_path) if (
            not isfile(join(base_source_path, f)) and 
            not f.startswith('.') and
            f not in ['doc', 'xml', 'config', 'gen-data', 'analysis', 'templates', 'RemoteSystemsTempFiles', 'banner', 'flash'])]
    return subprojects


def generate_subprojects_pages(base_source_path : str, subprojects : List):
    """
    Summarize documentation data for separate subprojects, save files with summary information
    
    :param      base_source_path:  The base source path of the project
    :param      subprojects:       List of subprojects to be processes
    """
    print("generate_subprojects_pages...")
    for subproject in subprojects:
        print(subproject)

        # TODO include only -used- files
        # NOTE see https://github.com/psycofdj/coverxygen for command details
        converxygen_command = f"python3 -m coverxygen --xml-dir {base_source_path}/{subproject}/xml\
        --src-dir {base_source_path}/{subproject} \
        --output {base_source_path}/analysis/code_coverage/report/{subproject}-doc-coverage.info \
        --kind=function,class,variable,struct,enum,file --scope=all \
        --exclude=.\/gen\/. --exclude=.\/ner-bert\/. --exclude=.\/flair\/. \
        --exclude=.\/analysis\/. --exclude=.\/googleads. --exclude=.\/external_ner\/. --exclude=.pl"

        genhtml_command = f"genhtml -q --title='{subproject}' --no-function-coverage \
        --no-branch-coverage  {base_source_path}/analysis/code_coverage/report/{subproject}-doc-coverage.info \
        -o {base_source_path}/analysis/code_coverage/report/{subproject}_coverage"

        system(converxygen_command)
        system(genhtml_command)    


def extract_summary_info(base_source_path : str, subprojects : List) -> Dict:
    """
    Summarize documentation coverage for whole project

    :param      base_source_path:  The base source path of the project
    :param      subprojects:       List of subprojects to be processes

    :returns:   subproject name : (count of items documented, count of items to be documented, percentage of documented)
                total info is returned with key "total"
    """

    subproject_coverage = {}
    for subproject in subprojects:
        lcov_command = f"lcov --summary={base_source_path}/analysis/code_coverage/report/{subproject}-doc-coverage.info"
        result = subprocess.run(lcov_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.decode('utf-8')

        lines = result.split('\n')
        coverage_info = [l for l in lines if l.strip().startswith('lines...')]
        if len(coverage_info) != 1:
            continue
        m = re.search('lines[\.]+\: ([0-9\%\.]+) \(([0-9]+)[^0-9]+([0-9]+)[^0-9]+\)', coverage_info[0])
        percentage = m.group(1)
        documented = m.group(2)
        total = m.group(3)

        subproject_coverage[subproject] = (documented, total, percentage)

    total_info = (sum([int(x[0]) for x in subproject_coverage.values()]), sum([int(x[1]) for x in subproject_coverage.values()]))
    subproject_coverage["total"] = (total_info[0], total_info[1], str(round(100*total_info[0] / total_info[1], 2)) + " %")

    return subproject_coverage


def find_broken_projects(base_source_path : str, subprojects : List) -> Dict:
    """
    Parse Doxyfile.warn file, extract list of errors for each subproject
    
    :param      base_source_path:  The base source path of the project
    :param      subprojects:       List of subprojects to be processes

    :return:    subproject name : its documentation errors
    """
    path_parts = dict()
    current_subproject = ""

    with open(f'{base_source_path}/Doxyfile.warn', "r") as f:
        for line in f.readlines():
            if line.startswith("/"):

                path_part = line.split(":")[0]
                path_parts_in_line = set([x for x in path_part.split("/") if x in subprojects])
                
                if len(path_parts_in_line) == 1:
                    current_subproject = path_parts_in_line.pop()
            
            if len(current_subproject) == 0:
                continue

            if not current_subproject in path_parts:
                path_parts[current_subproject] = ""
            path_parts[current_subproject] += line + "\n"

    return path_parts


def form_summary_page(base_source_path : str, subproject_coverage : Dict, broken_subprojects : Dict):
    """
    Generates html page to display whole project coverage
    
    :param      base_source_path:  The base source path of the project
    :param      subproject_coverage: [subproject name : (count of items documented, count of items to be documented, percentage of documented)]
    :param      broken_subprojects: [subproject name : its documentation errors]
    """

    with open(f'{base_source_path}/analysis/code_coverage/doc_coverge_template.html', "r") as f:
        html_code = f.read()
        
        html_code = html_code.replace("!!!Current date!!!", date.today().strftime("%d/%m/%Y"))

        total_info = subproject_coverage["total"]
        total_info_html = f'<td class="headerCovTableEntry">{total_info[0]}</td>\
        <td class="headerCovTableEntry">{total_info[1]}</td>\
        <td class="headerCovTableEntryLo">{total_info[2]}</td>'
        html_code = html_code.replace("!!!Total info!!!", total_info_html)


        sp_descr = ""
        for sp, sp_coverage in subproject_coverage.items():
            if sp == "total":
                continue

            url = f'{sp}_coverage/index.html'
                  
            percent = float(sp_coverage[2].split('%')[0])
            color_image = f"{sp}_coverage/ruby.png"
            if percent > 99.9:
                 color_image = f"{sp}_coverage/amber.png"       
            elif percent > 75.0:
                 color_image = f"{sp}_coverage/emerald.png"  
            white_image = f"{sp}_coverage/snow.png" 

            if sp in broken_subprojects:
                sp_text = f'(documentation was generated with errors, results are unreliable)'
                if len(broken_subprojects[sp]) < 1000:
                    errors_list = broken_subprojects[sp]
                else:
                    errors_list = "Errors list is too long, see Doxyfile.warn file."
            else:
                sp_text = ""
                errors_list = ""

            sp_descr += f'<tr>\
                <td class="coverFile"><a href="{url}">{sp}</a><span style="color:red" title="{errors_list}">{sp_text}</span></td>\
                      <td class="coverBar" align="center">\
                        <table border=0 cellspacing=0 cellpadding=1>\
                        <tr>\
                        <td class="coverBarOutline">\
                        <img src="{color_image}" width={int(percent)} height=10 alt="{sp_coverage[2]}"><img src="{white_image}" width={100-int(percent)} height=10 alt="{sp_coverage[2]}">\
                        </td></tr></table>\
                      </td>\
                      <td class="coverPerLo">{sp_coverage[2]}</td>\
                      <td class="coverNumLo">{sp_coverage[0]} / {sp_coverage[1]}</td>\
                    </tr>' 
        
        html_code = html_code.replace("!!!Subproject names!!!", sp_descr)
        
        with open(f'{base_source_path}/analysis/code_coverage/report/doc_coverage_summary.html', "w") as outp:
            outp.write(html_code)


def get_source_path() -> str:
    """
    Gets the root project folder. 
    Assumption: path to this script is <project root>/analysis/code_coverage
    """
    current_path = dirname(realpath(__file__))
    print(current_path)
    project_path = "/".join(current_path.split("/")[0:-2])
    return project_path



if __name__ == '__main__':

    source_path = get_source_path()
    print(f'source_path: {source_path}')

    subprojects = get_subprojects_list(source_path)
    generate_subprojects_pages(source_path, subprojects)
    subprojects_coverage = extract_summary_info(source_path, subprojects)
    broken_subprojects = find_broken_projects(source_path, subprojects)
    form_summary_page(source_path, subprojects_coverage, broken_subprojects)
